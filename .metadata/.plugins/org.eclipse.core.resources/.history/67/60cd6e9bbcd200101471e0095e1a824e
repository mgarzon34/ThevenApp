package com.circuitos.temporal.gui.commands;

import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.logging.Logger;

import com.circuitos.analisiscircuitos.dominio.Circuito;
import com.circuitos.analisiscircuitos.dominio.Componente;
import com.circuitos.analisiscircuitos.gui.controller.PanelDisenoController;
import com.circuitos.analisiscircuitos.gui.model.Cable;
import com.circuitos.analisiscircuitos.gui.model.PuntoConexion;
import com.circuitos.analisiscircuitos.gui.service.undo.DescripcionesAccion;

/**
 * Comando para eliminar un componente del diseño del circuito.
 * También guarda y restaura todas las conexiones asociadas.
 * 
 * @author Marco Antonio Garzón Palos
 * @version 1.0
 */
public class RemoveComponentCommand implements Command {
    private static final Logger logger=Logger.getLogger(RemoveComponentCommand.class.getName());
    
    private final PanelDisenoController controlador;
	private final Componente componente;
	private StackPane componenteVisual;
	private Pane zonaDibujo;
	private Circuito circuito;
	private String descripcion="Eliminar componente";
	private int oldPaneIndex=-1;
	private int oldListIndex=-1;
	private final List<CableInfo> cablesQuitados=new ArrayList<>();
	private boolean ejecutado=false;
    
	/** Estructura auxiliar para recordar dónde estaba cada cable. */
	private static final class CableInfo {
		final Cable cable;
		final int paneIndex;
		final int listIndex;
		CableInfo(Cable cable, int paneIndex, int listIndex) {
			this.cable=cable;
			this.paneIndex=paneIndex;
			this.listIndex=listIndex;
		}
	}
	
    /**
     * Constructor del comando de eliminar componente.
     * 
     * @param controlador Controlador del panel de diseño
     * @param componente Componente a eliminar
     */
    public RemoveComponentCommand(PanelDisenoController controlador, Componente componente) {
    	this.controlador=Objects.requireNonNull(controlador, "controlador");
    	this.componente=Objects.requireNonNull(componente, "componente");
    	this.descripcion=DescripcionesAccion.eliminar(componente);
    }
    
    
    /**
     * Busca en la zona de dibujo el {@link StackPane} que representa visualmente
     * a un componente del dominio.
     * 
     * @param comp		Componente cuya vista se quiere encontrar
     * @param zona		Zona de dibujo donde está la vista
     * @return StackPane asociado al componente o {@code null} si no se encuentra
     */
    private static StackPane findVista(Componente comp, Pane zona) {
    	for(Node n : zona.getChildren()) {
    		if(n instanceof StackPane sp && sp.getUserData() instanceof Componente c && c==comp) {
    			return sp;
    		}
    	}
    	return null;
    }
    
    /**
     * Comprueba si un cable está conectado a un componente.
     * 
     * @param cable			Cable a comprobar
     * @param comp			Componente con el que se verifica
     * @return {@code true} si está conectado, {@false} si no
     */
    private static boolean estaConectadoAComponente(Cable cable, Componente comp) {
    	PuntoConexion ini=cable.getInicio();
    	PuntoConexion fin=cable.getFin();
    	return(ini!=null && ini.getComponente()==comp) || (fin!=null && fin.getComponente()==comp);
    }
    
    /**
     * Restringe un valor entero al intervalo [min, max].
     */
    private static int clamp(int val, int min, int max) {
    	if(val<min) return min;
    	if(val>max) return max;
    	return val;
    }
    
    /* Implementación métodos de la interfaz */
    
    @Override
    public void ejecutar() {
    	if(ejecutado) return;
    	zonaDibujo=controlador.getZonaDibujo();
    	circuito=controlador.getCircuitoActual();
    	if(zonaDibujo==null || circuito==null) return;
    	
    	//encontrar la vista (StackPane) del componente por userData
    	componenteVisual=findVista(componente, zonaDibujo);
    	if(componenteVisual==null) return;
    	
    	//guardar índices de reinsertado
    	oldPaneIndex=zonaDibujo.getChildren().indexOf(componenteVisual);
    	oldListIndex=circuito.getComponentes().indexOf(componente);
    	
    	//encontrar y quitar todos los cables conectados a este componente
    	cablesQuitados.clear();
    	for(Node n : zonaDibujo.getChildren()) {
    		if(n instanceof Cable c) {
    			if(estaConectadoAComponente(c, componente)) {
    				int idxPane=zonaDibujo.getChildren().indexOf(c);
    				int idxList=controlador.getCablesCircuito().indexOf(c);
    				cablesQuitados.add(new CableInfo(c, idxPane, idxList));
    			}
    		}
    	}
    	if(!cablesQuitados.isEmpty()) {
    		this.descripcion=DescripcionesAccion.eliminar(componente);
    	}
    	//eliminar cables por referencia
    	for(CableInfo ci : cablesQuitados) {
    		zonaDibujo.getChildren().remove(ci.cable);
    		if(ci.listIndex>=0) controlador.getCablesCircuito().remove(ci.cable);
    	}
    	//eliminar vista y modelo del componente
    	zonaDibujo.getChildren().remove(componenteVisual);
    	circuito.getComponentes().remove(componente);
    	ejecutado=true;
    	logger.fine(() -> "Componente eliminado: "+componente.getId()
    		+ " (cables afectados="+cablesQuitados.size()+")");
    }
    
    @Override
    public void deshacer() {
    	if(!ejecutado || zonaDibujo==null || circuito==null || componenteVisual==null) return;
    	Parent parent=componenteVisual.getParent();
    	if(parent instanceof Pane p && p!=zonaDibujo) {
    		p.getChildren().remove(componenteVisual);
    	}
    	int li=clamp(oldListIndex, 0, circuito.getComponentes().size());
    	if(!circuito.getComponentes().contains(componente)) {
    		circuito.getComponentes().add(li, componente);
    	}
    	int pi=clamp(oldPaneIndex, 0, zonaDibujo.getChildren().size());
    	if(!zonaDibujo.getChildren().contains(componenteVisual)) {
    		zonaDibujo.getChildren().add(pi, componenteVisual);
    	}
    	for(CableInfo ci : cablesQuitados) {
    		Parent pc=ci.cable.getParent();
    		if(pc instanceof Pane p && p!=zonaDibujo) {
    			p.getChildren().remove(ci.cable);
    		}
    		int cpi=clamp(ci.paneIndex, 0, zonaDibujo.getChildren().size());
    		if(!zonaDibujo.getChildren().contains(ci.cable)) {
    			zonaDibujo.getChildren().add(cpi, ci.cable);
    		}
    		int cli=(ci.listIndex<0) ? controlador.getCablesCircuito().size()
    				: clamp(ci.listIndex, 0, controlador.getCablesCircuito().size());
    		if(!controlador.getCablesCircuito().contains(ci.cable)) {
    			controlador.getCablesCircuito().add(cli, ci.cable);
    		}
    	}
    	ejecutado=false;
    	if(controlador.getCableManager()!=null) {
    		controlador.getCableManager().actualizarEtiquetasYRutas();
    	}
    	logger.fine(() -> "Componente restaurado: "+componente.getId()
    		+" (cables restaurados="+cablesQuitados.size()+")");
    }
    
    @Override
    public String getDescripcion() {
        return descripcion;
    }
    
    @Override
    public boolean esValido() {
    	return componente!=null && controlador!=null;
    }
}