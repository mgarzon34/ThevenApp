package com.circuitos.AnalisisCircuitos.gui.commands;

import java.util.Objects;
import java.util.logging.Logger;

import com.circuitos.AnalisisCircuitos.dominio.Circuito;
import com.circuitos.AnalisisCircuitos.dominio.Componente;

import javafx.scene.Parent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;

/**
 * Comando para añadir un componente al diseño del circuito.
 * Solo maneja componentes (no cables).
 * 
 * @author Marco Antonio Garzón Palos
 * @version 1.0
 */
public class AddCommand implements Command {
	private static final Logger logger=Logger.getLogger(AddCommand.class.getName());
	
	private final Circuito circuito;
	private final Componente componente;
	private final Pane zonaDibujo;
	private final StackPane componenteVisual; 
	
	private int paneIndexUsado=-1;
	private int listIndexUsado=-1;
	private boolean ejecutado=false;
	
	public AddCommand(Circuito circuito, Componente componente, Pane zonaDibujo, StackPane componenteVisual) {
		this.circuito=Objects.requireNonNull(circuito, "circuito");
		this.componente=Objects.requireNonNull(componente, "componente");
		this.zonaDibujo=Objects.requireNonNull(zonaDibujo, "zonaDibujo");
		this.componenteVisual=Objects.requireNonNull(componenteVisual, "componenteVisual");
	}
	
	@Override
	public void ejecutar() {
		if(!ejecutado) {
			//primera vez: almacenar índices al final de cada contenedor
			paneIndexUsado=zonaDibujo.getChildren().size();
			listIndexUsado=circuito.getComponentes().size();
		} else {
			//redo: clamp por si cambió el tamaño
			paneIndexUsado=clamp(paneIndexUsado, 0, zonaDibujo.getChildren().size());
			listIndexUsado=clamp(listIndexUsado, 0, circuito.getComponentes().size());
		}
		//si la vista tiene otro padre, desacoplar primero
		Parent parent=componenteVisual.getParent();
		if(parent!=null && parent!=zonaDibujo && parent instanceof Pane p) {
			p.getChildren().remove(componenteVisual);
		}
		//reubicar en pane en índice exacto (evita duplicado)
		if(zonaDibujo.getChildren().contains(componenteVisual)) {
			zonaDibujo.getChildren().remove(componenteVisual);
		}
		zonaDibujo.getChildren().add(paneIndexUsado, componenteVisual);
		//reubicar en la lista del circuito (evita duplicado)
		if(circuito.getComponentes().contains(componente)) {
			circuito.getComponentes().remove(componente);
		}
		circuito.getComponentes().add(listIndexUsado, componente);
		ejecutado=true;
		logger.fine("Componente añadido: "+componente.getId());
	}

	@Override
	public void deshacer() {
		//Solo eliminar el componente (cables independientes)
		if(!ejecutado) return;
		circuito.getComponentes().remove(componente);
		zonaDibujo.getChildren().remove(componenteVisual);
		ejecutado=false;
		logger.fine("Componente eliminado por -deshacer-: "+componente.getId());
	}

	@Override
	public String getDescripcion() {
		return "Añadir "+componente.getClass().getSimpleName();
	}
	
	@Override
	public boolean esValido() {
		//El comando es válido si el componente y su representación visual existen
		return componente!=null && componenteVisual!=null && 
				zonaDibujo!=null && circuito!=null;
	}
	
	/**
	 * Restringe un valor entero dentro del intervalo [min, max].
	 * 
	 * @param val			Valor a evaluar
	 * @param min			Límite inferior (incluido)
	 * @param max			Límite superior (incluido)
	 * @return El valor limitado dentro del rango [min, max]
	 */
	private static int clamp(int val, int min, int max) {
		if(val<min) return min;
		if(val>max) return max;
		return val;
	}
}
